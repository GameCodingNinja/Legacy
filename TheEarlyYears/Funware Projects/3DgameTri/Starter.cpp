
/************************************************************************
*
*    PRODUCT:         Starter
*
*    FILE NAME:       Starter.cpp
*
*    DESCRIPTION:     The begining of all great API windows programs
*
*    IMPLEMENTATION: How it's done 
*
*
*    Copyright(c) by Howard C Rosenorn
*    All Rights Reserved
*
************************************************************************/

                             // Enables strict compiler error checking. Without this, the compiler doesn't
#define STRICT               // know the difference between many Windows data types. Very bad to leave out. Doesn't add to code size
#include "GDefines.h"        // Header file with #defines
#include <windows.h>         // Windows header file for creating windows programs. This is a must have.
#include <windowsx.h>        // Macros the makes windows programming easer and more readable. Doesn't add to code size

#include "Starter.h"         // Header file for this *.cpp file.
#include "gTools.h"          // A misc group of useful functions
#include "complex.h"         // Texture header generated by OBJ parsering tool

// Globals
PCStarterWnd pStarterWnd;


// These are globals used by the 3D engine and must be setup
unsigned short int *gusiVBufer;
//int giBufWidth = 640, giBufHeight = 480;
//int giBufWidth = 800, giBufHeight = 600;
int giBufWidth = 1024, giBufHeight = 768;
float gfBufWidthDiv2 = giBufWidth/2, gfBufHeightDiv2 = giBufHeight/2;
int *giZBuffer;
float gfMaxZDistance = 700;
float gfMinZDistance = 10.0;
unsigned short int *gusiShadeTbl;
float gfCameraScaleX = giBufWidth * 0.885;
float gfCameraScaleY = -gfCameraScaleX;


int pvs[9] = { 4,    // main
               3,    // building1
               4,    // building2
               2,    // building3
               3,    // building4
               3,    // tunnel1
               4,    // tunnel2
               3,    // tunnel2
               3 };  // tunnel2


/************************************************************************
*
*                       Non Object Related Functions
*
************************************************************************/


/************************************************************************
*    FUNCTION NAME:         WinMain                                                             
*
*    DESCRIPTION:           The entry point for all good windows programs
*
*    FUNCTION PARAMETERS:
*    Input:    HINSTANCE hInst - This progams instance
*              HINSTANCE hPrevInstance - Of no value to 32 bit windows programs
*              LPSTR lpszCmdParam - The command line is sent by Windows. The command
*                                   originally has the path to this program but
*                                   Windows parses it out before it hands it over.
*                                   To get the command line with the path in it you
*                                   need to call GetCommandLine() API call.
*              int nCmdShow - Specifies how the window is to be shown.
*                             Example: SW_SHOWMINIMIZED, SW_SHOWMAXIMIZED   
*
*    Output:   int - Usually it's the last message wParam.
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*    HCR           9/27/99       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

int WINAPI WinMain( HINSTANCE hInst, HINSTANCE hPrevInstance,
                    LPSTR lpszCmdParam, int nCmdShow )
{
    MSG msg;

    // Set wParam to 0 in case need to return right away.
    msg.wParam = 0;

    // Create the parent window object
    CStarterWnd StarterWnd;
    pStarterWnd = &StarterWnd;

    // Create the parent window
    if( StarterWnd.CreateParentWnd( hInst, nCmdShow ) )
    {
        // Do some startup Inits
        if( StarterWnd.GameInit() )
        {
            // A game requires an infinite loop
            while( TRUE )
            {
                // Check for waiting messages
                if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
                {
                    // Is it time to quit
                    if( msg.message == WM_QUIT )
                        break;

                    // Change the format of certain messages
                    TranslateMessage( &msg );

                    // Pass the message to WndProc() for processing
                    DispatchMessage( &msg );
                }
                else
                {
                    // Call the game loop
                    StarterWnd.GameLoop();
                }
            }
        }
    }

    return msg.wParam;

}   // WinMain


/************************************************************************
*    FUNCTION NAME:         WndProc                                                             
*
*    DESCRIPTION:           Standard Windows message handler.
*                           We are using this to call our object functions
*
*    FUNCTION PARAMETERS:
*    Input:    HWND hwnd      - Handle of the window receiving the message
*              UINT Message   - Message being sent 
*              WPARAM wParam  - Additional information included with message
*              LPARAM lParam  - Additional information included with message
*
*    Output:   returntype - Description
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*    HCR           9/27/99       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

LRESULT CALLBACK WndProc( HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam )
{
    switch( Message )
    {
        HANDLE_MSG( hwnd, WM_DESTROY,   pStarterWnd->OnDestroy );
        HANDLE_MSG( hwnd, WM_COMMAND,   pStarterWnd->OnCommand );
        HANDLE_MSG( hwnd, WM_CREATE,    pStarterWnd->OnCreate );
        HANDLE_MSG( hwnd, WM_MOUSEMOVE, pStarterWnd->OnMouseMove );
        default:
            return DefWindowProc( hwnd, Message, wParam, lParam );
    }

} // WndProc


/************************************************************************
*
*                      Window Object Functions
*
************************************************************************/


/************************************************************************
*    FUNCTION NAME:              Constructer                                                             
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*                  10/22/99       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

CStarterWnd::CStarterWnd()
{
    // Init class members
    hScreenDC = NULL;
    gameRunning = FALSE;
    giZBuffer = NULL;
    gusiVBufer = NULL;
    gusiShadeTbl = NULL;
    gameLoopCounter = 0;
    gameLoopTimer = 0;
    bufferRenderTime = 0;

}   // Constructer


/************************************************************************
*    FUNCTION NAME:              Destructer                                                             
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*                  10/22/99       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

CStarterWnd::~CStarterWnd()
{
}   // Destructer



/************************************************************************
*    FUNCTION NAME:         CreateParentWnd()                                                             
*
*    DESCRIPTION:           Create the parent Window
*
*    FUNCTION PARAMETERS:
*    Input:    HWND hwnd      - Handle of the window receiving the message
*      LPCREATESTRUCT lpCreateStruct  - Structure used in window creation 
*
*    Output:   returntype - Description
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*    HCR           9/27/99       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

BOOL CStarterWnd::CreateParentWnd( HINSTANCE hInstance, int nCmdShow )
{
    // Save the program instance
    hInst = hInstance;

    // Register the parent window with Windows
    if( !RegisterWnd( hInst ) )
        return FALSE;

    // Create the parent window
    if( !CreateWnd( hInst, nCmdShow ) )
        return FALSE;

    return TRUE;

}   // CreateParentWnd


/************************************************************************
*    FUNCTION NAME:         RegisterWnd                                                             
*
*    DESCRIPTION:           All windows created with CreateWindow
*                           must be registered first. This does not include
*                           windows controls like buttons, listboxex and such
*                           because they register themselves.
*
*    FUNCTION PARAMETERS:
*    Input:    HINSTANCE hInst - This progams instance
*
*    Output:   BOOL            - Returns TRUE or FALSE to indicate if
*                                the task was secessful.
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*    HCR           9/27/99       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

BOOL CStarterWnd::RegisterWnd( HINSTANCE hInstance )
{
    WNDCLASSEX w;

    w.cbSize = sizeof( WNDCLASSEX );
    w.style = CS_HREDRAW|CS_VREDRAW;
    w.lpfnWndProc = WndProc;
    w.cbClsExtra = 0;
    w.cbWndExtra = 0;
    w.hInstance = hInstance;
    w.hIcon = LoadIcon( hInst, "AppIcon" );
    w.hIconSm = NULL;
    w.hCursor = LoadCursor( NULL, IDC_ARROW );
    w.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    w.lpszMenuName = NULL;//"Menu_1";
    w.lpszClassName = WINDOW_NAME;

    return ( RegisterClassEx(&w) != 0 );

}   // Starter_RegisterWnd 


/************************************************************************
*    FUNCTION NAME:         CreateWnd                                                             
*
*    DESCRIPTION:           Create the parent window
*
*    FUNCTION PARAMETERS:
*    Input:    HINSTANCE hInst - This progams instance
*
*              int nCmdShow    - Specifies how the window is to be shown.
*                                Example: SW_SHOWMINIMIZED, SW_SHOWMAXIMIZED
*
*    Output:   HWND - A handle to the newly created window
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*    HCR           9/27/99       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

BOOL CStarterWnd::CreateWnd( HINSTANCE hInstance, int nCmdShow )
{
    RECT rect;
    unsigned int dwExStyle = WS_EX_APPWINDOW|WS_EX_WINDOWEDGE;
    unsigned int dwStyle = WS_OVERLAPPED;
    
    // Fill the rect structure
    SetRect( &rect, 0,0,giBufWidth+10,giBufHeight+10 );
    
    // Calculate how big the window will be with the required client size
    AdjustWindowRectEx( &rect, dwStyle, true, dwExStyle );

    // Create the parent window & save the window handle
    hParentWnd = CreateWindowEx( dwExStyle, WINDOW_NAME, WINDOW_TITLE,
                                 dwStyle|WS_SYSMENU|WS_MINIMIZEBOX|WS_VISIBLE|CS_OWNDC,
                                 (GetSystemMetrics( SM_CXSCREEN ) - (rect.right-rect.left)) / 2,
                                 (GetSystemMetrics( SM_CYSCREEN ) - (rect.bottom-rect.top)) / 2, 
                                 rect.right-rect.left, rect.bottom-rect.top,
                                 NULL, NULL, hInstance, NULL );

    // Create the parent window & save the window handle
    /*hParentWnd = CreateWindow( WINDOW_NAME, WINDOW_TITLE, WS_OVERLAPPEDWINDOW|WS_VISIBLE|CS_OWNDC,
                               CW_USEDEFAULT, CW_USEDEFAULT,
                               CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL );*/

    // Slightly Higher Priority                                     
    SetForegroundWindow( hParentWnd );
                                            
    // Make it the focus
    SetFocus( hParentWnd );

    StartGame();

    // Make sure we have a handle to the window
    if( hParentWnd == NULL )
        return FALSE;

    return TRUE;

}   // CreateWnd


/************************************************************************
*    FUNCTION NAME:         OnDestroy                                                             
*
*    DESCRIPTION:           Standard Windows OnDestroy message handler.
*
*    FUNCTION PARAMETERS:
*    Input:    HWND hwnd      - Handle of the window receiving the message 
*
*    Output:   returntype - Description
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*                  6/17/99       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

void CStarterWnd::OnDestroy( HWND hwnd )
{
    // Unload the game
    GameShutDown( hwnd );
    
    // This causes the WinMain to fall out of it's while loop
    PostQuitMessage( 0 );

} // OnDestroy


/************************************************************************
*    FUNCTION NAME:         OnCreate()                                                             
*
*    DESCRIPTION:           Standard Windows OnCreate message handler.
*
*    FUNCTION PARAMETERS:
*    Input:    HWND hwnd      - Handle of the window receiving the message
*      LPCREATESTRUCT lpCreateStruct  - Structure used in window creation 
*
*    Output:   returntype - Description
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*    h rosenorn    3/30/00       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

BOOL CStarterWnd::OnCreate( HWND hwnd, LPCREATESTRUCT lpCreateStruct )
{
    // Center this window on the screen
    //CenterWindow( hwnd, 820, 650 );

    return TRUE;

}   // Starter_OnCreate


/************************************************************************
*    FUNCTION NAME:         OnCommand                                                             
*
*    DESCRIPTION:           Standard Windows OnCommand message handler.
*
*    FUNCTION PARAMETERS:
*    Input:    HWND hwnd       - Handle of the window receiving the message
*              int id          - Menu ID of the of the control.
*              HWND hwndCtl    - Handle of the control receiving the message
*              UINT codeNotify - The action taking place
*
*    Output:   returntype - Description
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*                  6/17/99       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

void CStarterWnd::OnCommand( HWND hwnd, int id, HWND hwndCtl, UINT codeNotify )
{
    switch( id )
    {
        case MNU_START:
            StartGame();            
        break;

        case MNU_EXIT:
            // Destroy the parent window
            DestroyWindow( hwnd );
        break;
    }

}   // OnCommand


/************************************************************************
*    FUNCTION NAME:         StartGame                                                             
*
*    DESCRIPTION:           Start the game
*
*    FUNCTION PARAMETERS:
*    Input:    var1type Var1Name - Description
*              var2type Var2Name - Description 
*
*    Output:   BOOL - True or False depending on if successful
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*                  12/29/03       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

void CStarterWnd::StartGame()
{
    RECT rect;

    // get the window rect
    GetWindowRect( hParentWnd, &rect );

    // confine the mouse to the window rect because
    // it will only remain hidden if it is inside our window
    //ClipCursor( &rect );
    
    // Set the center point for the mouse for movement comparison
    mouseCenterPt.x = rect.left + ((rect.right - rect.left) / 2);
    mouseCenterPt.y = rect.top + ((rect.bottom - rect.top) / 2);

    // Hide the mouse
    ShowCursor( false );

    // Set the mouse position to the middle of the window
    SetCursorPos( mouseCenterPt.x, mouseCenterPt.y );

    gameLoopTimer = 0;
    gameRunning = TRUE;

}   // StartGame


/************************************************************************
*    FUNCTION NAME:         StopGame                                                             
*
*    DESCRIPTION:           Stop the game
*
*    FUNCTION PARAMETERS:
*    Input:    var1type Var1Name - Description
*              var2type Var2Name - Description 
*
*    Output:   BOOL - True or False depending on if successful
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*                  12/29/03       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

void CStarterWnd::StopGame()
{
    gameRunning = false;
    //ClipCursor( NULL );
    ShowCursor( true );

}   // StopGame


/************************************************************************
*    FUNCTION NAME:         GameInit                                                             
*
*    DESCRIPTION:           Do some game startup inits
*
*    FUNCTION PARAMETERS:
*    Input:    var1type Var1Name - Description
*              var2type Var2Name - Description 
*
*    Output:   BOOL - True or False depending on if successful
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*                  12/29/03       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

BOOL CStarterWnd::GameInit()
{                                    
    BOOL result = FALSE;
    int i;

    char polyStr[9][20] = { "main.ply",
                            "building1.ply",
                            "building2.ply",
                            "building3.ply",
                            "building4.ply",
                            "tunnel1.ply",
                            "tunnel2.ply",
                            "tunnel3.ply",
                            "tunnel4.ply" };

    char normStr[9][20] = { "main.nor",
                            "building1.nor",
                            "building2.nor",
                            "building3.nor",
                            "building4.nor",
                            "tunnel1.nor",
                            "tunnel2.nor",
                            "tunnel3.nor",
                            "tunnel4.nor" };

                             // all textures related to the floor
    int array[] = { -FLOOR,  ET_water01, ET_tile02, ET_metal02, ET_metal04, ET_skin01, ET_tile01,
                             // all textures related to the walls           
                    -WALL,   ET_bspdemotext128_2, ET_panel01, ET_panel02, ET_tech01 };

    // Get the device context to the main screen
    hScreenDC = GetDC( hParentWnd );

    // Make sure we have a screen DC
    if( hScreenDC == NULL )
    {
        PostMsg( "Init Error", "Can't get a DC from the window handle. Your system resources may be low so try restarting your computer." );
        goto HANDLE_ERROR;
    }

    // Allocate the Z Buffer
    giZBuffer = new int[ giBufWidth * giBufHeight ];
    if( giZBuffer == NULL )
    {
        PostMsg( "Init Error", "Can't allocate Z buffer. Your system resources may be low so try restarting your computer." );
        goto HANDLE_ERROR;
    }

    // Zero out the ZBuffer
    memsetQuad( giZBuffer, 0, giBufWidth * giBufHeight );

    // Init the classes using the screens DC. That way it doesn't have to make one
    buffer.InitActiveDC( hScreenDC );

    // Create the video buffer
    if( !buffer.CreateDIBSectionBuffer( giBufWidth, -giBufHeight, BIT_COUNT_16 ) )
    {
        PostMsg( "Init Error", "Can't allocate background buffer. Your system resources may be low so try restarting your computer." );
        goto HANDLE_ERROR;
    }

    gusiVBufer = (unsigned short int *)buffer.GetPtrToDIBsectionBits();

    if( !lightList.SetLightCount( 2 ) )
        PostMsg( "Error", "Unable to create light list." );

    lightList.SetLightIntensity( 1, 30 );
    lightList.SetLightType( 1, ELT_AMBIENT, EShade_NONE );

    lightList.SetLightPoint( 0, 0, 10000, 7000 );
    lightList.SetLightIntensity( 0, 150 );
    lightList.SetLightRange( 0, 80, 200 );
    lightList.SetLightType( 0, ELT_POINT, EShade_GOURAUD ); // ELT_AMBIENT

    //////////////////////////////////////////////////////
    //            Load Texture Library
    //////////////////////////////////////////////////////

    // Load the attack ship texture library 
    if( !mapTxt.LoadFromFile( "complex.b16" ) )
    {
        PostMsg( "Init Error", "Unable to load BT file" );
        goto HANDLE_ERROR;
    }

    //////////////////////////////////////////////////////
    //           Generate Shaded Table
    //////////////////////////////////////////////////////

    // Allocate the shaded lookup table
    gusiShadeTbl = new unsigned short int[ SHADE_COUNT * COLOR_COUNT_16_BIT ];
    if( gusiShadeTbl == NULL )
    {
        PostMsg( "Init Error", "Can't allocate shaded lookup table. Your system resources may be low so try restarting your computer." );
        goto HANDLE_ERROR;
    }

    // Generate the 16 bit shaded table
    Generate16BitShadedTable( gusiShadeTbl );


    for( i = 0; i < 9; ++i )
    {
        // Set the index
        mapMsh[i].SetIndex( i );

        mapMsh[i].SetLightList( lightList );

        //////////////////////////////////////////////////////
        //            Load Polygon Objects
        //////////////////////////////////////////////////////

        // Load the map polygon object 
        if( !mapMsh[i].LoadFromFile( polyStr[i], DONT_CALC_NORMALS ) )
        {
            PostMsg( "Init Error", "Unable to load map PLY file" );
            goto HANDLE_ERROR;
        }

        // load the normal file.
        if( !mapMsh[i].LoadNormals( normStr[i] ) )
        {
            PostMsg( "Error", "Unable to load NOR file." );
            goto HANDLE_ERROR;
        }

        // Set the texture libraries
        mapMsh[i].SetTextureLibrary( mapTxt );

        // Set's up our collision/reaction types
        // this can only be done last after all has been loaded.
        mapMsh[i].SetTriType( array, sizeof(array)/sizeof(int) );

        // Set the type of mesh
        if( i < 5 )
            mapMsh[i].SetType( EMT_ROOM );
        else
            mapMsh[i].SetType( EMT_HALL );

        // Set the mesh to the manger
        mshMgr.SetCell( &mapMsh[i] );
    }

    result = TRUE;

HANDLE_ERROR:;

    return result;

}   // GameInit


/************************************************************************
*    FUNCTION NAME:         GameShutDown                                                             
*
*    DESCRIPTION:           Shutdown the game
*
*    FUNCTION PARAMETERS:
*    Input:    var1type Var1Name - Description
*              var2type Var2Name - Description 
*
*    Output:   BOOL - True or False depending on if successful
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*                  12/29/03       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

void CStarterWnd::GameShutDown( HWND hwnd )
{
    // Stop the game
    gameRunning = FALSE;

    // Turn off mouse clipping
    ClipCursor( NULL );
    
    // Free the buffer
    buffer.Free();

    // Free the z buffer
    if( giZBuffer )
    {
        delete [] giZBuffer;
        giZBuffer = NULL;
    }

    // Free the shaded table
    if( gusiShadeTbl )
    {
        delete [] gusiShadeTbl;
        gusiShadeTbl = NULL;
    }

    // Release the screen DC. Make sure this is the last item to free
    if( hScreenDC != NULL )
        ReleaseDC( hwnd, hScreenDC );

}   // GameLoop


/************************************************************************
*    FUNCTION NAME:         GameLoop                                                             
*
*    DESCRIPTION:           Call to excute the game loop
*
*    FUNCTION PARAMETERS:
*    Input:    var1type Var1Name - Description
*              var2type Var2Name - Description 
*
*    Output:   BOOL - True or False depending on if successful
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*                  12/29/03       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

void CStarterWnd::GameLoop()
{
    if( gameRunning )
    {
        // Is it time to render again
        if( gameLoopTimer < timeGetTime() )
        {
            // Get user imput
            GetUserImput();

            // React to collision
            ReactToCollision();

            // Render buffer and show it
            RenderBuffer();

            // Reset the timer
            gameLoopTimer = timeGetTime() + 30;
        }
    }
    else
    {
        // See if we want to start again
        if( HIBYTE( GetAsyncKeyState( VK_HOME ) ) )
        {
            StartGame();    
        }
    }
}   // GameLoop


/************************************************************************
*    FUNCTION NAME:         GetUserImput                                                             
*
*    DESCRIPTION:           Act upon what the user is doing
*
*    FUNCTION PARAMETERS:
*    Input:    var1type Var1Name - Description
*              var2type Var2Name - Description 
*
*    Output:   BOOL - True or False depending on if successful
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*                  12/29/03       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

void CStarterWnd::GetUserImput()
{
    short int keyState;
    POINT mousePt;
    float viewX=0, viewZ=0;
    buttonDown = false;

    // See if we want to escape out
    keyState = GetAsyncKeyState( VK_ESCAPE );
    if( HIBYTE( keyState ) )
    {
        if( gameRunning )
            StopGame();
        return;    
    }

    keyState = GetAsyncKeyState( VK_UP );
    if( HIBYTE( keyState ) )
    {
        buttonDown = true;
        viewZ = -MAX_MOVEMENT_SPEED;
    }

    keyState = GetAsyncKeyState( VK_DOWN );
    if( HIBYTE( keyState ) )
    {
        buttonDown = true;
        viewZ = MAX_MOVEMENT_SPEED;
    }

    keyState = GetAsyncKeyState( VK_LEFT );
    if( HIBYTE( keyState ) )
    {
        buttonDown = true;
        viewX = MAX_MOVEMENT_SPEED;
    }

    keyState = GetAsyncKeyState( VK_RIGHT );
    if( HIBYTE( keyState ) )
    {
        buttonDown = true;
        viewX = -MAX_MOVEMENT_SPEED;
    }    

    // Get the mouse X & Y position
    GetCursorPos( &mousePt );

    // Reset the cursor positions
    SetCursorPos( mouseCenterPt.x, mouseCenterPt.y );

    // Add in the translation
    matrixYZ.Translate( viewX, GRAVITY, viewZ );

    // Do the Y rotation. We are using the difference between the center abd the new offsets
    matrixYZ.Rotate( 0, (((float)mouseCenterPt.x - (float)mousePt.x)/5.5), 0 );

    // The X rotation has to be done seperately and added into final matrix
    matrixX.Rotate( (((float)mouseCenterPt.y - (float)mousePt.y)/5.5), 0, 0 );

}   // GetUserImput


/************************************************************************
*    FUNCTION NAME:         ReactToCollision                                                             
*
*    DESCRIPTION:           Check for collision and react to it. I feel
*                           that collision reaction is best when it is
*                           handled outside the engine because every
*                           situation is different. Let the engine indicate
*                           it has hit something, but that is it.
*
*    FUNCTION PARAMETERS:
*    Input:    var1type Var1Name - Description
*              var2type Var2Name - Description 
*
*    Output:   returntype - None
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*                  12/29/03       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

void CStarterWnd::ReactToCollision()
{
    int index, colType, meshIndex;
    float x, z, y, pointD; 
    double dist;
    CPoint pt, normal;
    int closestFloorIndex;
    int floorObjIndex;
    int closestWallIndex;
    int wallObjIndex;
    int count;

    // Start the inital distances as far away so we can see if
    // we are getting closer. We only want to collide (do Intersection Collision)
    // with the closest polygons.
    double closestFloorDistance;
    double closestWallDistance;

    // init
    closestFloorDistance=DIST_FROM_FLOOR*20;
    closestWallDistance=DIST_FROM_WALL*20;
    closestFloorIndex = -1;
    closestWallIndex = -1;

    count = mshMgr.GetCount();

    if( count > 2 )
        count = 2;

    for( int i = 0; i < count; ++i )
    {
        meshIndex = mshMgr.GetIndex( i );
            
        index = 0;

        do
        {
            // Check for a bounding sphere collision. This is fastest and we'll
            // use this as a means of finding only the closest triangle to do
            // do our final test which is the intersection test.
            colType = mapMsh[ meshIndex ].IsCollision_BoundSphere( index, dist, pt, 6 );

            ///////////////////////////
            // Did we hit a floor?
            ///////////////////////////
            if( colType == FLOOR )
            {
                // Find the closest floor polygon and save the index
                if( dist < closestFloorDistance )
                {
                    closestFloorDistance = dist;
                    closestFloorIndex = index;
                    floorObjIndex = meshIndex;
                }
            }
            ///////////////////////////
            // Did we hit a wall?
            ///////////////////////////
            else if( colType == WALL )
            {
                // Find the closest floor polygon and save the index
                if( dist < closestWallDistance )
                {
                    closestWallDistance = dist;
                    closestWallIndex = index;
                    wallObjIndex = meshIndex;
                }
            }
        }
        while( ++index < mapMsh[ meshIndex ].GetTriCount() && index != -1 );
    }
            
    // react to the floor if we touched one
    if( closestFloorIndex > -1 )
    {
        // Final check for floor collision. Slower then bounding sphere collision but very
        // accurate which is why we do it after the bounding sphere check.
        if( mapMsh[floorObjIndex].IsCollision_Intersection( matrixYZ, closestFloorIndex, DIST_FROM_FLOOR, 
                                                            pt, normal, pointD ) )
        {
            // Compute the y delta
            if( normal.y != 0 )
                y = ((normal.x + normal.z + pointD) / -normal.y) + DIST_FROM_FLOOR;
            else
                y = (normal.x + normal.z + pointD) + DIST_FROM_FLOOR;
            
            // Move the camera
            matrixYZ.Translate( 0, -y, 0 );
        }
    }

    // Only react to the wall if we are moving. If we hit the wall, do a wall glide
    if( closestWallIndex > -1 && buttonDown )
    {
        // Final check for wall collision. Will return
        // true if we are to go further.
        if( mapMsh[wallObjIndex].IsCollision_Intersection( matrixYZ, closestWallIndex, DIST_FROM_WALL, 
                                                           pt, normal, pointD ) )
        {
            z = x = 0;

            // Glide along the wall directly in front or behind us
            if( fabs(normal.z) > fabs(normal.x) )
            {
                // The wall is in front of us
                if( normal.z > 0 )
                {
                    z = -(((normal.x + pointD) / (-normal.z)) + DIST_FROM_WALL);
                    x = normal.x;

                    // Cap the speed
                    if( z > 0 )
                        z = 0;
                }
                // The wall is behind us
                else if( normal.z <= 0 )
                {
                    z = -(((normal.x + pointD) / (-normal.z)) - DIST_FROM_WALL);
                    x = -normal.x;

                    // Cap the speed
                    if( z < 0 )
                        z = 0;
                }
            }
            // Glide along the wall to our right or left side
            else if( fabs(normal.x) > fabs(normal.z) )
            {
                // The wall is on our right side
                if( normal.x > 0 )
                {
                    z = -normal.z;
                    x = -(((normal.z + pointD) / (-normal.x)) + DIST_FROM_WALL);

                    // Cap the speed
                    if( x > 0 )
                        x = 0;
                }
                // The wall is on our left side
                else if( normal.x <= 0 )
                {
                    z = -normal.z;
                    x = -(((normal.z + pointD) / (-normal.x)) - DIST_FROM_WALL);

                    // Cap the speed
                    if( x < 0 )
                        x = 0;
                }                
            }

           // Move it along the wall
           matrixYZ.Translate( x, 0, z );
        }
    }

}   // ReactToCollision


/************************************************************************
*    FUNCTION NAME:         RenderBuffer                                                             
*
*    DESCRIPTION:           Render to the buffer
*
*    FUNCTION PARAMETERS:
*    Input:    var1type Var1Name - Description
*              var2type Var2Name - Description 
*
*    Output:   BOOL - True or False depending on if successful
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*                  12/29/03       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

void CStarterWnd::RenderBuffer()
{
    unsigned int start, stop;
    int polyCount=0, objCount=0;
    CMatrix matrixMrg;

    // Use a temporary matrix to merge the two matrixes into one
    matrixMrg.MergeMatrix( matrixYZ.matrix );
    matrixMrg.MergeMatrix( matrixX.matrix );

    //memsetQuad( giZBuffer, 0, giBufWidth * giBufHeight ); 

    // Get the starting time
    start = timeGetTime();

    // Cull all the objects
    mshMgr.CullBoundingSpheres( matrixMrg );

    // Render the mesh objects
    mshMgr.RenderCells( matrixMrg, polyCount, objCount );


    // Ho long did it take to render?
    stop = timeGetTime() - start;

    // Lets see how long this is taking
    wsprintf( debugStr, "render Time: %d;  Tri Count: %d;  Obj Count: %d;  Buf Time: %u", stop, polyCount, objCount, bufferRenderTime );
    TextOut( buffer.Handle(), 0, 0, debugStr, strlen(debugStr) );
    

    // Get the starting time
    start = timeGetTime();
    
    // Disply the buffer to the screen
    buffer.Draw( hScreenDC );

    bufferRenderTime = timeGetTime() - start;

}   // RenderBuffer


/************************************************************************
*    FUNCTION NAME:         OnMouseMove()                                                             
*
*    DESCRIPTION:           Standard Windows OnMouseMove message handler.
*
*    FUNCTION PARAMETERS:
*    Input:    HWND hwnd      - Handle of the window receiving the message 
*
*    Output:   returntype - Description
*
*    HISTORY:
*    Name          Date          Comment
*    -------------------------------------------------------------------
*    h rosenorn    3/30/00       Function Created
*    -------------------------------------------------------------------
*    UserID        MM/DD/YY      Description of any changes
************************************************************************/

void CStarterWnd::OnMouseMove( HWND hwnd, int X, int Y, UINT keyFlags )
{
    if( gameRunning )
    {
        
        //MessageBeep(0);
    }
}   // OnMouseMove